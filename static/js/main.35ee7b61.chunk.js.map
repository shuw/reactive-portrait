{"version":3,"sources":["logic/States.js","logic/StateMachine.js","components/Snippet.js","components/SnippetTransition.js","components/ReactivePortrait.js","App.js","serviceWorker.js","index.js"],"names":["States","options","DIRECTION_PROB","IDLE_BEFORE_DIRECTION","lookAround","idle","events","tick50Ms","minTimeElapsedInState","wave","probability","smile","lookingAround","lookingAround2","attention","thumbsUp","thinking","customReaction1","customReaction2","customReaction3","customReaction4","customReaction5","bye","lookLeft","lookingLeft","lookRight","lookingRight","lookDown","lookingDown","lookUp","lookingUp","mouseUp","mouseUpLeft","lookingUpLeft","mouseUpRight","lookingUpRight","mouseLeft","mouseRight","mouseDown","mouseDownLeft","lookingDownLeft","mouseDownRight","lookingDownRight","almostFinished","knockKnock","StateMachine","initialStateName","this","states","get","_setState","previousState","state","statesWithoutFiles","event","_updateState","name","newStates","info","Date","getTime","startTime","randomFloat","Math","random","entries","Object","sort","entry","newStateName","newStateInfo","constructor","console","error","stateName","triggeringEvent","Snippet","props","onVideoLoaded","e","videoRef","current","currentTime","getVideoStartTime","onVideoError","hasError","React","createRef","readyState","isVideoReady","duration","style","position","top","left","width","height","borderRadius","WebkitMaskImage","ref","autoPlay","muted","loop","playsInline","onError","onLoadedData","opacity","src","mediaPath","Component","SnippetTransition","updateTransition","transitionFraction","snippetRef","transitionStartTime","newName","playFromBeginning","timeElapsed","min","setState","isAlmostFinished","hasFailedToLoad","nextProps","nextState","_timer","window","setInterval","clearInterval","key","ReactivePortrait","invokeEvent","onMouseMove","rootRef","currTime","lastMouseEvent","angle","side","direction","rect","getBoundingClientRect","centerX","x","round","centerY","y","offsetX","clientX","offsetY","clientY","sqrt","pow","atan","PI","onAttention","onLoadedCalled","onLoaded","stateMachine","defaultSnippet","oldState","getState","newState","addEventListener","message","verboseLogging","log","eventName","logVerbose","previousTriggeringEvent","getNewState","onSnippetChanged","onMouseEnter","onClick","snippetsMediaPath","App","onPortraitChanged","snippetName","params","URL","document","location","searchParams","names","split","portraits","map","display","padding","textAlign","hideStateInfo","length","className","right","color","href","target","paddingTop","fontSize","Boolean","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.35ee7b61.chunk.js","sourcesContent":["export default class States {\n  static get(options) {\n    var DIRECTION_PROB, IDLE_BEFORE_DIRECTION;\n    if (options.lookAround) {\n      DIRECTION_PROB = 1;\n      IDLE_BEFORE_DIRECTION = 1;\n    } else {\n      DIRECTION_PROB = 0.02;\n      IDLE_BEFORE_DIRECTION = 5;\n    }\n\n    return {\n      idle: {\n        events: {\n          tick50Ms: {\n            minTimeElapsedInState: 10,\n            wave: { probability: 0.001 },\n            smile: { probability: 0.0005 },\n            lookingAround: { probability: 0.0003 },\n            lookingAround2: { probability: 0.0002 },\n          },\n\n          attention: {\n            wave: { probability: 0.2 },\n            thumbsUp: { probability: 0.2 },\n            smile: { probability: 0.2 },\n            thinking: { probability: 0.2 },\n            customReaction1: { probability: 0.2 },\n            customReaction2: { probability: 0.2 },\n            customReaction3: { probability: 0.2 },\n            customReaction4: { probability: 0.2 },\n            customReaction5: { probability: 0.2 },\n          },\n\n          thumbsUp: { thumbsUp: {} },\n\n          bye: { bye: {} },\n          lookLeft: { lookingLeft: {} },\n          lookRight: { lookingRight: {} },\n          lookDown: { lookingDown: {} },\n          lookUp: { lookingUp: {} },\n\n          mouseUp: {\n            minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n            lookingUp: { probability: DIRECTION_PROB },\n          },\n          mouseUpLeft: {\n            minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n            lookingUpLeft: { probability: DIRECTION_PROB },\n          },\n          mouseUpRight: {\n            minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n            lookingUpRight: { probability: DIRECTION_PROB },\n          },\n          mouseLeft: {\n            minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n            lookingLeft: { probability: DIRECTION_PROB },\n          },\n          mouseRight: {\n            minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n            lookingRight: { probability: DIRECTION_PROB },\n          },\n          mouseDown: {\n            minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n            lookingDown: { probability: DIRECTION_PROB * 0.5 },\n          },\n          mouseDownLeft: {\n            minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n            lookingDownLeft: { probability: DIRECTION_PROB },\n          },\n          mouseDownRight: {\n            minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n            lookingDownRight: { probability: DIRECTION_PROB },\n          },\n        },\n      },\n\n      bye: {\n        events: { almostFinished: { wave: {} } },\n      },\n\n      smile: { events: { almostFinished: { idle: {} } } },\n      wave: { events: { almostFinished: { idle: {} } } },\n      thumbsUp: { events: { almostFinished: { idle: {} } } },\n      knockKnock: { events: { almostFinished: { idle: {} } } },\n      thinking: { events: { almostFinished: { idle: {} } } },\n      lookingAround: { events: { almostFinished: { idle: {} } } },\n      lookingAround2: { events: { almostFinished: { idle: {} } } },\n      lookingUp: { events: { almostFinished: { idle: {} } } },\n      lookingUpLeft: { events: { almostFinished: { idle: {} } } },\n      lookingUpRight: { events: { almostFinished: { idle: {} } } },\n      lookingLeft: { events: { almostFinished: { idle: {} } } },\n      lookingRight: { events: { almostFinished: { idle: {} } } },\n      lookingDown: { events: { almostFinished: { idle: {} } } },\n      lookingDownLeft: { events: { almostFinished: { idle: {} } } },\n      lookingDownRight: { events: { almostFinished: { idle: {} } } },\n      customReaction1: { events: { almostFinished: { idle: {} } } },\n      customReaction2: { events: { almostFinished: { idle: {} } } },\n      customReaction3: { events: { almostFinished: { idle: {} } } },\n      customReaction4: { events: { almostFinished: { idle: {} } } },\n      customReaction5: { events: { almostFinished: { idle: {} } } },\n    };\n  }\n}\n","import States from \"./States\";\n\n/**\n * TODO:\n * - on fileNotFound condition, re-trigger the previous event with new state\n */\nexport default class StateMachine {\n  constructor(initialStateName, options = {}) {\n    this.states = States.get(options);\n    this._setState(initialStateName, null /* no triggering event*/);\n    this.previousState = this.state;\n    this.statesWithoutFiles = {};\n  }\n\n  getState() {\n    return this.state;\n  }\n\n  getNewState(event) {\n    this._updateState(event);\n    return this.state;\n  }\n\n  _updateState(event) {\n    // handle failure by going back to idle\n    if (event === \"fileNotFound\") {\n      this.statesWithoutFiles[this.state.name] = true;\n      this.state = this.previousState;\n      return;\n    }\n\n    var newStates = this.state.info.events[event];\n    if (!newStates) {\n      return;\n    }\n\n    if (newStates.minTimeElapsedInState) {\n      var timeInStateMs = new Date().getTime() - this.state.startTime;\n      if (timeInStateMs < newStates.minTimeElapsedInState * 1000) {\n        return;\n      }\n    }\n\n    const randomFloat = Math.random();\n    var probability = 0.0;\n\n    const entries = Object.entries(newStates).sort(() => 0.5 - Math.random());\n    for (const entry of entries) {\n      const newStateName = entry[0];\n      const newStateInfo = entry[1];\n\n      // skip properties, or states without files\n      if (\n        newStateInfo.constructor !== Object ||\n        newStateName in this.statesWithoutFiles\n      ) {\n        continue;\n      }\n\n      if (!(newStateName in this.states)) {\n        console.error(\"ERROR, state not found: \" + newStateName);\n        continue;\n      }\n\n      probability += newStateInfo.probability || 1.0;\n      if (probability < randomFloat) {\n        continue;\n      }\n\n      // found new state, reset timer\n      this._setState(newStateName, event);\n      return;\n    }\n  }\n\n  _setState(stateName, triggeringEvent) {\n    this.previousState = this.state;\n    this.state = {\n      name: stateName,\n      info: this.states[stateName],\n      triggeringEvent: triggeringEvent,\n      startTime: new Date().getTime(),\n    };\n  }\n}\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\n// How close to the end of a video before returning it's almost finished\nconst VIDEO_ALMOST_FINISHED_THRESHOLD_S = 0.1;\n\n// Encapsulates a Video Snippet\nexport default class Snippet extends React.Component {\n  static propTypes = {\n    width: PropTypes.number,\n    height: PropTypes.number,\n    name: PropTypes.string,\n    opacity: PropTypes.number,\n    onVideoLoaded: PropTypes.func,\n    mediaPath: PropTypes.string,\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.hasError = false;\n    this.videoRef = React.createRef();\n  }\n\n  isVideoReady() {\n    return this.videoRef.current && this.videoRef.current.readyState === 4;\n  }\n\n  playFromBeginning() {\n    if (!this.isVideoReady()) {\n      return;\n    }\n\n    this.videoRef.current.currentTime = this.getVideoStartTime();\n  }\n\n  isAlmostFinished() {\n    if (!this.isVideoReady()) {\n      return false;\n    }\n\n    return (\n      this.videoRef.current.duration - this.videoRef.current.currentTime <\n      VIDEO_ALMOST_FINISHED_THRESHOLD_S\n    );\n  }\n\n  onVideoLoaded = (e) => {\n    this.videoRef.current.currentTime = this.getVideoStartTime();\n    if (this.props.onVideoLoaded) {\n      this.props.onVideoLoaded(e);\n    }\n  };\n\n  onVideoError = (e) => {\n    this.hasError = true;\n  };\n\n  hasFailedToLoad() {\n    return this.hasError;\n  }\n\n  getVideoStartTime() {\n    if (this.props.name === \"idle\" && this.videoRef.current?.duration) {\n      return Math.random() * this.videoRef.current.duration;\n    }\n    return 0;\n  }\n\n  render() {\n    return (\n      <div\n        style={{\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          width: this.props.width,\n          height: this.props.height,\n          borderRadius: this.props.width / 2,\n          WebkitMaskImage:\n            \"-webkit-radial-gradient(circle, white 100%, black 100%)\",\n        }}\n      >\n        <video\n          ref={this.videoRef}\n          autoPlay\n          muted\n          loop\n          playsInline\n          onError={this.onVideoError}\n          onLoadedData={this.onVideoLoaded}\n          width={this.props.width}\n          height={this.props.height}\n          style={{\n            opacity: this.props.opacity,\n          }}\n        >\n          <source src={this.props.mediaPath + \"/\" + this.props.name + \".mov\"} />\n        </video>\n      </div>\n    );\n  }\n}\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport Snippet from \"./Snippet\";\n\nconst VIDEO_CROSS_FADE_TIME_MS = 400;\nconst FRAME_INTERVAL_MS = 30;\n\n// Manages cross-fade between two Snippet Videos\nexport default class SnippetTransition extends React.Component {\n  static propTypes = {\n    width: PropTypes.number,\n    height: PropTypes.number,\n    name: PropTypes.string,\n    newName: PropTypes.string,\n    mediaPath: PropTypes.string,\n    onError: PropTypes.func,\n    onVideoLoaded: PropTypes.func,\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.transitionStartTime = null;\n    this.state = {\n      transitionFraction: 1.0,\n    };\n\n    this.snippetRef = React.createRef();\n  }\n\n  isAlmostFinished() {\n    return this.snippetRef.current?.isAlmostFinished() ?? false;\n  }\n\n  hasFailedToLoad() {\n    return this.snippetRef.current?.hasFailedToLoad() ?? false;\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if (nextProps.newName === this.props.newName) {\n      return true;\n    }\n\n    nextState.transitionFraction = 0.0;\n    this.transitionStartTime = null;\n\n    return true;\n  }\n\n  componentDidMount() {\n    this._timer = window.setInterval(this.updateTransition, FRAME_INTERVAL_MS);\n  }\n\n  componentWillUnmount() {\n    window.clearInterval(this._timer);\n  }\n\n  updateTransition = () => {\n    if (this.state.transitionFraction >= 1.0) {\n      return;\n    }\n\n    if (!this.snippetRef.current) {\n      return;\n    }\n\n    if (!this.snippetRef.current.isVideoReady()) {\n      // wait for video to be ready before transitioning\n      return;\n    }\n\n    // reset transition\n    if (!this.transitionStartTime) {\n      this.transitionStartTime = new Date().getTime();\n\n      // play from beginning (if not resetting to idle state)\n      if (this.props.name !== \"idle\" || this.props.newName !== \"idle\") {\n        this.snippetRef.current.playFromBeginning();\n      }\n    }\n\n    var timeElapsed = new Date().getTime() - this.transitionStartTime;\n    var transitionFraction = Math.min(\n      timeElapsed / VIDEO_CROSS_FADE_TIME_MS,\n      1.0\n    );\n\n    this.setState({\n      transitionFraction: transitionFraction,\n    });\n  };\n\n  onVideoLoaded = () => {\n    this.props.onVideoLoaded();\n  };\n\n  render() {\n    if (this.props.newName && this.props.newName !== this.props.name) {\n      return (\n        <div>\n          <Snippet\n            key={this.props.name}\n            mediaPath={this.props.mediaPath}\n            width={this.props.width}\n            height={this.props.height}\n            name={this.props.name}\n            opacity={1.0}\n          />\n          <Snippet\n            ref={this.snippetRef}\n            key={this.props.newName}\n            mediaPath={this.props.mediaPath}\n            opacity={this.state.transitionFraction}\n            width={this.props.width}\n            height={this.props.height}\n            name={this.props.newName}\n            onVideoLoaded={this.onVideoLoaded}\n          />\n        </div>\n      );\n    } else {\n      return (\n        <div>\n          <Snippet\n            ref={this.snippetRef}\n            key={this.props.name}\n            mediaPath={this.props.mediaPath}\n            width={this.props.width}\n            height={this.props.height}\n            name={this.props.name}\n            onVideoLoaded={this.onVideoLoaded}\n            opacity={1.0}\n          />\n        </div>\n      );\n    }\n  }\n}\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport StateMachine from \"../logic/StateMachine\";\nimport SnippetTransition from \"./SnippetTransition\";\n\nconst DIRECTION_RADIUS_BUFFER = 0.75;\nconst MIN_DURATION_BETWEEN_MOUSE_EVENT_MS = 50;\n\n// TODO\n// * Incorporate yawn state\n// * Incorporate gyro signal\n// * Support for delayed state change. Short term memory.\nexport default class ReactivePortrait extends React.Component {\n  static defaultSnippet = \"idle\";\n\n  static propTypes = {\n    width: PropTypes.number,\n    height: PropTypes.number,\n    onSnippetChanged: PropTypes.func,\n    snippetsMediaPath: PropTypes.string,\n    onLoaded: PropTypes.func,\n    options: PropTypes.object,\n  };\n\n  constructor(props) {\n    super(props);\n    this.stateMachine = new StateMachine(\n      ReactivePortrait.defaultSnippet,\n      props.options ?? {}\n    );\n    this.rootRef = React.createRef();\n    this.lastMouseEvent = new Date().getTime();\n    this.snippetRef = React.createRef();\n    this.onLoadedCalled = false;\n\n    this.state = {\n      stateMachine: this.stateMachine,\n      oldState: this.stateMachine.getState(),\n      newState: this.stateMachine.getState(),\n    };\n  }\n\n  componentDidMount() {\n    this._timer = window.setInterval(this.tick50Ms, 100);\n    window.addEventListener(\"mousemove\", this.onMouseMove);\n  }\n\n  componentWillUnmount() {\n    window.clearInterval(this._timer);\n  }\n\n  tick50Ms = () => {\n    this.invokeEvent(\"tick50Ms\");\n\n    if (this.snippetRef.current?.hasFailedToLoad()) {\n      this.invokeEvent(\"fileNotFound\");\n    }\n\n    if (this.snippetRef.current?.isAlmostFinished()) {\n      this.invokeEvent(\"almostFinished\");\n    }\n  };\n\n  onMouseMove = (event) => {\n    if (!this.rootRef.current) {\n      return;\n    }\n\n    const currTime = new Date().getTime();\n    const elapsedMs = currTime - this.lastMouseEvent;\n    if (elapsedMs < MIN_DURATION_BETWEEN_MOUSE_EVENT_MS) {\n      return;\n    }\n    this.lastMouseEvent = currTime;\n\n    const rect = this.rootRef.current.getBoundingClientRect();\n    const centerX = rect.x + Math.round(rect.width / 2);\n    const centerY = rect.y + Math.round(rect.height / 2);\n\n    const offsetX = event.clientX - centerX;\n    const offsetY = event.clientY - centerY;\n\n    const distance = Math.sqrt(Math.pow(offsetX, 2) + Math.pow(offsetY, 2));\n\n    // ignore directional mouse movements that are too close\n    if (distance < rect.width * DIRECTION_RADIUS_BUFFER) {\n      return;\n    }\n\n    var angle, side;\n    if (offsetX > 0) {\n      angle = Math.atan((-1 * offsetY) / offsetX) * (180 / Math.PI);\n      side = \"Right\";\n    } else {\n      angle = Math.atan(offsetY / offsetX) * (180 / Math.PI);\n      side = \"Left\";\n    }\n\n    var direction;\n    if (angle > 67.5) {\n      direction = \"Up\";\n    } else if (angle > 22.5) {\n      direction = \"Up\" + side;\n    } else if (angle > -22.5) {\n      direction = side;\n    } else if (angle > -67.5) {\n      direction = \"Down\" + side;\n    } else {\n      direction = \"Down\";\n    }\n\n    this.invokeEvent(\"mouse\" + direction);\n  };\n\n  onAttention = () => {\n    this.invokeEvent(\"attention\");\n  };\n\n  logVerbose(message) {\n    if (this.props.options.verboseLogging) {\n      console.log(message);\n    }\n  }\n\n  invokeEvent(eventName) {\n    if (this.props.options.verboseLogging && eventName !== \"tick50Ms\") {\n      this.logVerbose(\"event: \" + eventName);\n    }\n\n    var previousTriggeringEvent = this.stateMachine.state.triggeringEvent;\n\n    var newState = this.stateMachine.getNewState(eventName);\n    if (newState.name === this.state.newState.name) {\n      return;\n    }\n\n    var oldState;\n    if (eventName === \"fileNotFound\") {\n      oldState = newState;\n\n      // if file not found, then re-trigger the previous event to find a new one\n      if (previousTriggeringEvent !== null) {\n        this.logVerbose(\n          \"Re-triggering event because file not found: \" +\n            previousTriggeringEvent\n        );\n        newState = this.stateMachine.getNewState(previousTriggeringEvent);\n      }\n    } else {\n      oldState = this.state.newState;\n    }\n\n    if (this.props.onSnippetChanged) {\n      this.props.onSnippetChanged(newState.name);\n    }\n\n    this.setState({\n      oldState: oldState,\n      newState: newState,\n    });\n  }\n\n  onVideoLoaded = () => {\n    if (!this.onLoadedCalled) {\n      this.onLoadedCalled = true;\n    }\n    if (this.props.onLoaded) {\n      this.props.onLoaded();\n    }\n  };\n\n  render() {\n    return (\n      <div\n        ref={this.rootRef}\n        onMouseEnter={this.onAttention}\n        onClick={this.onAttention}\n        style={{\n          position: \"relative\",\n          width: this.props.width,\n          height: this.props.height,\n        }}\n      >\n        <SnippetTransition\n          ref={this.snippetRef}\n          mediaPath={this.props.snippetsMediaPath}\n          width={this.props.width}\n          height={this.props.height}\n          name={this.state.oldState.name}\n          newName={this.state.newState.name}\n          onVideoLoaded={this.onVideoLoaded}\n        />\n      </div>\n    );\n  }\n}\n","import React from \"react\";\nimport ReactivePortrait from \"./components/ReactivePortrait\";\nimport \"./App.css\";\n\nconst MEDIA_PATH = \"https://shuw.github.io/reactive-portrait-media/\";\nconst MEDIA_PATH_DEBUG = \"http://localhost:3001/\";\n\nexport default class App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      snippetName: ReactivePortrait.defaultSnippet,\n    };\n  }\n\n  onPortraitChanged = (snippetName) => {\n    this.setState({ snippetName: snippetName });\n  };\n\n  render() {\n    const params = new URL(document.location).searchParams;\n    const names = (params.get(\"names\") ?? params.get(\"name\") ?? \"shuw\").split(\n      \",\"\n    );\n    const isDebugMode = params.get(\"debug\") !== null;\n    const mediaPath = isDebugMode ? MEDIA_PATH_DEBUG : MEDIA_PATH;\n\n    const portraits = names.map((name) => {\n      return (\n        <div\n          key={name}\n          style={{\n            display: \"inline-block\",\n            width: \"400px\",\n            padding: \"20px\",\n            textAlign: \"center\",\n          }}\n        >\n          <ReactivePortrait\n            options={{\n              lookAround: params.get(\"lookAround\") !== null,\n              verboseLogging: params.get(\"verboseLogging\") !== null,\n            }}\n            snippetsMediaPath={mediaPath + name}\n            onSnippetChanged={this.onPortraitChanged}\n            width={400}\n            height={400}\n          />\n        </div>\n      );\n    });\n\n    const hideStateInfo =\n      params.get(\"hideStateInfo\") !== null || portraits.length !== 1;\n\n    return (\n      <div className=\"App\">\n        <a\n          style={{\n            position: \"absolute\",\n            top: \"20px\",\n            right: \"20px\",\n            color: \"#aaa\",\n          }}\n          href=\"https://github.com/shuw/reactive-portrait\"\n          target=\"_blnk\"\n        >\n          Source Code\n        </a>\n        <div style={{ paddingTop: \"150px\" }}>{portraits}</div>\n        {hideStateInfo ? null : (\n          <div style={{ color: \"#aaa\", paddingTop: \"10px\", fontSize: \"20px\" }}>\n            {this.state.snippetName}\n          </div>\n        )}\n      </div>\n    );\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}
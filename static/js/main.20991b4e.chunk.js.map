{"version":3,"sources":["logic/StateMachine.js","components/Snippet.js","components/SnippetTransition.js","components/ReactivePortrait.js","App.js","serviceWorker.js","index.js"],"names":["URL","document","location","searchParams","get","DIRECTION_PROB","IDLE_BEFORE_DIRECTION","States","idle","transitions","tick50","minTimeElapsedInState","wave","probability","smile","lookingAround","lookingAround2","attention","thumbsUp","thinking","bye","lookLeft","lookingLeft","lookRight","lookingRight","lookDown","lookingDown","lookUp","lookingUp","mouseUp","mouseUpLeft","lookingUpLeft","mouseUpRight","lookingUpRight","mouseLeft","mouseRight","mouseDown","mouseDownLeft","lookingDownLeft","mouseDownRight","lookingDownRight","almostFinished","knockKnock","StateMachine","initialStateName","this","_setState","_state","event","_updateState","stateInfo","name","_stateStartTime","newStates","Date","getTime","randomFloat","Math","random","Object","entries","entry","newStateName","stateName","info","Snippet","props","onVideoLoaded","e","videoRef","current","currentTime","getVideoStartTime","onVideoError","hasError","React","createRef","readyState","isVideoReady","duration","style","position","top","left","width","height","borderRadius","WebkitMaskImage","ref","autoPlay","muted","loop","playsInline","onError","onLoadedData","opacity","src","mediaPath","Component","SnippetTransition","updateTransition","state","transitionFraction","snippetRef","transitionStartTime","newName","playFromBeginning","timeElapsed","min","setState","isAlmostFinished","hasFailedToLoad","nextProps","nextState","_timer","window","setInterval","clearInterval","key","ReactivePortrait","tick50Ms","invokeEvent","onMouseMove","rootRef","currTime","lastMouseEvent","angle","side","direction","rect","getBoundingClientRect","centerX","x","round","centerY","y","offsetX","clientX","offsetY","clientY","sqrt","pow","atan","PI","onAttention","onLoadedCalled","onLoaded","stateMachine","defaultSnippet","oldState","getState","newState","addEventListener","eventName","getNewState","onSnippetChanged","onMouseEnter","onClick","snippetsMediaPath","App","onPortraitChanged","snippetName","params","portraits","split","map","display","padding","hideStateInfo","length","className","paddingTop","Boolean","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.20991b4e.chunk.js","sourcesContent":["if (new URL(document.location).searchParams.get(\"lookAround\") !== null) {\n  var DIRECTION_PROB = 1;\n  var IDLE_BEFORE_DIRECTION = 1;\n} else {\n  var DIRECTION_PROB = 0.02;\n  var IDLE_BEFORE_DIRECTION = 5;\n}\n\n// TODO\n// * States to introduce:\n// looking around, smile, silly, all directions, multiple idle states\nconst States = {\n  idle: {\n    transitions: {\n      tick50: {\n        minTimeElapsedInState: 10,\n        wave: { probability: 0.001 },\n        smile: { probability: 0.0005 },\n        lookingAround: { probability: 0.0003 },\n        lookingAround2: { probability: 0.0002 },\n      },\n\n      attention: {\n        wave: { probability: 0.2 },\n        thumbsUp: { probability: 0.3 },\n        smile: { probability: 0.3 },\n        thinking: { probability: 0.2 },\n      },\n\n      thumbsUp: { thumbsUp: {} },\n\n      bye: { bye: {} },\n      lookLeft: { lookingLeft: {} },\n      lookRight: { lookingRight: {} },\n      lookDown: { lookingDown: {} },\n      lookUp: { lookingUp: {} },\n\n      mouseUp: {\n        minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n        lookingUp: { probability: DIRECTION_PROB },\n      },\n      mouseUpLeft: {\n        minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n        lookingUpLeft: { probability: DIRECTION_PROB },\n      },\n      mouseUpRight: {\n        minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n        lookingUpRight: { probability: DIRECTION_PROB },\n      },\n      mouseLeft: {\n        minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n        lookingLeft: { probability: DIRECTION_PROB },\n      },\n      mouseRight: {\n        minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n        lookingRight: { probability: DIRECTION_PROB },\n      },\n      mouseDown: {\n        minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n        lookingDown: { probability: DIRECTION_PROB * 0.5 },\n      },\n      mouseDownLeft: {\n        minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n        lookingDownLeft: { probability: DIRECTION_PROB },\n      },\n      mouseDownRight: {\n        minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n        lookingDownRight: { probability: DIRECTION_PROB },\n      },\n    },\n  },\n\n  bye: {\n    transitions: { almostFinished: { wave: {} } },\n  },\n\n  smile: { transitions: { almostFinished: { idle: {} } } },\n  wave: { transitions: { almostFinished: { idle: {} } } },\n  thumbsUp: { transitions: { almostFinished: { idle: {} } } },\n  knockKnock: { transitions: { almostFinished: { idle: {} } } },\n  thinking: { transitions: { almostFinished: { idle: {} } } },\n  lookingAround: { transitions: { almostFinished: { idle: {} } } },\n  lookingAround2: { transitions: { almostFinished: { idle: {} } } },\n  lookingUp: { transitions: { almostFinished: { idle: {} } } },\n  lookingUpLeft: { transitions: { almostFinished: { idle: {} } } },\n  lookingUpRight: { transitions: { almostFinished: { idle: {} } } },\n  lookingLeft: { transitions: { almostFinished: { idle: {} } } },\n  lookingRight: { transitions: { almostFinished: { idle: {} } } },\n  lookingDown: { transitions: { almostFinished: { idle: {} } } },\n  lookingDownLeft: { transitions: { almostFinished: { idle: {} } } },\n  lookingDownRight: { transitions: { almostFinished: { idle: {} } } },\n};\n\nexport default class StateMachine {\n  constructor(initialStateName) {\n    this._setState(initialStateName);\n  }\n\n  getState() {\n    return this._state;\n  }\n\n  getNewState(event) {\n    this._updateState(event);\n    return this._state;\n  }\n\n  _updateState(event) {\n    var stateInfo = States[this._state.name];\n\n    // handle failure by going back to idle\n    if (event === \"failed\") {\n      this._setState(\"idle\");\n\n      // disable minTimeElapsedInState\n      this._stateStartTime = 0;\n      return;\n    }\n\n    var newStates = stateInfo.transitions[event];\n    if (!newStates) {\n      return;\n    }\n\n    if (newStates.minTimeElapsedInState) {\n      var timeInStateMs = new Date().getTime() - this._stateStartTime;\n      if (timeInStateMs < newStates.minTimeElapsedInState * 1000) {\n        return;\n      }\n    }\n\n    const randomFloat = Math.random();\n    var probability = 0.0;\n    for (const entry of Object.entries(newStates)) {\n      const newStateName = entry[0];\n      if (!(newStateName in States)) {\n        continue;\n      }\n\n      probability += entry[1].probability || 1.0;\n      if (probability < randomFloat) {\n        continue;\n      }\n\n      // found new state, reset timer\n      this._setState(newStateName);\n      return;\n    }\n  }\n\n  _setState(stateName) {\n    this._state = {\n      name: stateName,\n      info: States[stateName],\n    };\n    this._stateStartTime = new Date().getTime();\n  }\n}\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\n// How close to the end of a video before returning it's almost finished\nconst VIDEO_ALMOST_FINISHED_THRESHOLD_S = 0.1;\n\n// Encapsulates a Video Snippet\nexport default class Snippet extends React.Component {\n  static propTypes = {\n    width: PropTypes.number,\n    height: PropTypes.number,\n    name: PropTypes.string,\n    opacity: PropTypes.number,\n    onVideoLoaded: PropTypes.func,\n    mediaPath: PropTypes.string,\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.hasError = false;\n    this.videoRef = React.createRef();\n  }\n\n  isVideoReady() {\n    return this.videoRef.current && this.videoRef.current.readyState === 4;\n  }\n\n  playFromBeginning() {\n    if (!this.isVideoReady()) {\n      return;\n    }\n\n    this.videoRef.current.currentTime = this.getVideoStartTime();\n  }\n\n  isAlmostFinished() {\n    if (!this.isVideoReady()) {\n      return false;\n    }\n\n    return (\n      this.videoRef.current.duration - this.videoRef.current.currentTime <\n      VIDEO_ALMOST_FINISHED_THRESHOLD_S\n    );\n  }\n\n  onVideoLoaded = (e) => {\n    this.videoRef.current.currentTime = this.getVideoStartTime();\n    if (this.props.onVideoLoaded) {\n      this.props.onVideoLoaded(e);\n    }\n  };\n\n  onVideoError = (e) => {\n    this.hasError = true;\n  };\n\n  hasFailedToLoad() {\n    return this.hasError;\n  }\n\n  getVideoStartTime() {\n    if (this.props.name === \"idle\" && this.videoRef.current?.duration) {\n      return Math.random() * this.videoRef.current.duration;\n    }\n    return 0;\n  }\n\n  render() {\n    return (\n      <div\n        style={{\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          width: this.props.width,\n          height: this.props.height,\n          borderRadius: this.props.width / 2,\n          WebkitMaskImage:\n            \"-webkit-radial-gradient(circle, white 100%, black 100%)\",\n        }}\n      >\n        <video\n          ref={this.videoRef}\n          autoPlay\n          muted\n          loop\n          playsInline\n          onError={this.onVideoError}\n          onLoadedData={this.onVideoLoaded}\n          width={this.props.width}\n          height={this.props.height}\n          style={{\n            opacity: this.props.opacity,\n          }}\n        >\n          <source src={this.props.mediaPath + \"/\" + this.props.name + \".mov\"} />\n        </video>\n      </div>\n    );\n  }\n}\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport Snippet from \"./Snippet\";\n\nconst VIDEO_CROSS_FADE_TIME_MS = 400;\nconst FRAME_INTERVAL_MS = 30;\n\n// Manages cross-fade between two Snippet Videos\nexport default class SnippetTransition extends React.Component {\n  static propTypes = {\n    width: PropTypes.number,\n    height: PropTypes.number,\n    name: PropTypes.string,\n    newName: PropTypes.string,\n    mediaPath: PropTypes.string,\n    onError: PropTypes.func,\n    onVideoLoaded: PropTypes.func,\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.transitionStartTime = null;\n    this.state = {\n      transitionFraction: 1.0,\n    };\n\n    this.snippetRef = React.createRef();\n  }\n\n  isAlmostFinished() {\n    return this.snippetRef.current?.isAlmostFinished() ?? false;\n  }\n\n  hasFailedToLoad() {\n    return this.snippetRef.current?.hasFailedToLoad() ?? false;\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if (nextProps.newName === this.props.newName) {\n      return true;\n    }\n\n    nextState.transitionFraction = 0.0;\n    this.transitionStartTime = null;\n\n    return true;\n  }\n\n  componentDidMount() {\n    this._timer = window.setInterval(this.updateTransition, FRAME_INTERVAL_MS);\n  }\n\n  componentWillUnmount() {\n    window.clearInterval(this._timer);\n  }\n\n  updateTransition = () => {\n    if (this.state.transitionFraction >= 1.0) {\n      return;\n    }\n\n    if (!this.snippetRef.current) {\n      return;\n    }\n\n    if (!this.snippetRef.current.isVideoReady()) {\n      // wait for video to be ready before transitioning\n      return;\n    }\n\n    // reset transition\n    if (!this.transitionStartTime) {\n      this.transitionStartTime = new Date().getTime();\n\n      // play from beginning (if not resetting to idle state)\n      if (this.props.name !== \"idle\" || this.props.newName !== \"idle\") {\n        this.snippetRef.current.playFromBeginning();\n      }\n    }\n\n    var timeElapsed = new Date().getTime() - this.transitionStartTime;\n    var transitionFraction = Math.min(\n      timeElapsed / VIDEO_CROSS_FADE_TIME_MS,\n      1.0\n    );\n\n    this.setState({\n      transitionFraction: transitionFraction,\n    });\n  };\n\n  onVideoLoaded = () => {\n    this.props.onVideoLoaded();\n  };\n\n  render() {\n    if (this.props.newName && this.props.newName !== this.props.name) {\n      return (\n        <div>\n          <Snippet\n            key={this.props.name}\n            mediaPath={this.props.mediaPath}\n            width={this.props.width}\n            height={this.props.height}\n            name={this.props.name}\n            opacity={1.0}\n          />\n          <Snippet\n            ref={this.snippetRef}\n            key={this.props.newName}\n            mediaPath={this.props.mediaPath}\n            opacity={this.state.transitionFraction}\n            width={this.props.width}\n            height={this.props.height}\n            name={this.props.newName}\n            onVideoLoaded={this.onVideoLoaded}\n          />\n        </div>\n      );\n    } else {\n      return (\n        <div>\n          <Snippet\n            ref={this.snippetRef}\n            key={this.props.name}\n            mediaPath={this.props.mediaPath}\n            width={this.props.width}\n            height={this.props.height}\n            name={this.props.name}\n            onVideoLoaded={this.onVideoLoaded}\n            opacity={1.0}\n          />\n        </div>\n      );\n    }\n  }\n}\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport StateMachine from \"../logic/StateMachine\";\nimport SnippetTransition from \"./SnippetTransition\";\n\nconst DIRECTION_RADIUS_BUFFER = 0.75;\nconst MIN_DURATION_BETWEEN_MOUSE_EVENT_MS = 50;\n\n// TODO\n// * Incorporate yawn state\n// * Incorporate gyro signal\n// * Support for delayed state change. Short term memory.\nexport default class ReactivePortrait extends React.Component {\n  static defaultSnippet = \"idle\";\n\n  static propTypes = {\n    width: PropTypes.number,\n    height: PropTypes.number,\n    onSnippetChanged: PropTypes.func,\n    snippetsMediaPath: PropTypes.string,\n    onLoaded: PropTypes.func,\n  };\n\n  constructor(props) {\n    super(props);\n    this.stateMachine = new StateMachine(ReactivePortrait.defaultSnippet);\n    this.rootRef = React.createRef();\n    this.lastMouseEvent = new Date().getTime();\n    this.snippetRef = React.createRef();\n    this.onLoadedCalled = false;\n\n    this.state = {\n      stateMachine: this.stateMachine,\n      oldState: this.stateMachine.getState(),\n      newState: this.stateMachine.getState(),\n    };\n  }\n\n  componentDidMount() {\n    this._timer = window.setInterval(this.tick50Ms, 100);\n    window.addEventListener(\"mousemove\", this.onMouseMove);\n  }\n\n  componentWillUnmount() {\n    window.clearInterval(this._timer);\n  }\n\n  tick50Ms = () => {\n    this.invokeEvent(\"tick50Ms\");\n\n    if (this.snippetRef.current?.hasFailedToLoad()) {\n      this.invokeEvent(\"failed\");\n    }\n\n    if (this.snippetRef.current?.isAlmostFinished()) {\n      this.invokeEvent(\"almostFinished\");\n    }\n  };\n\n  onMouseMove = (event) => {\n    if (!this.rootRef.current) {\n      return;\n    }\n\n    const currTime = new Date().getTime();\n    const elapsedMs = currTime - this.lastMouseEvent;\n    if (elapsedMs < MIN_DURATION_BETWEEN_MOUSE_EVENT_MS) {\n      return;\n    }\n    this.lastMouseEvent = currTime;\n\n    const rect = this.rootRef.current.getBoundingClientRect();\n    const centerX = rect.x + Math.round(rect.width / 2);\n    const centerY = rect.y + Math.round(rect.height / 2);\n\n    const offsetX = event.clientX - centerX;\n    const offsetY = event.clientY - centerY;\n\n    const distance = Math.sqrt(Math.pow(offsetX, 2) + Math.pow(offsetY, 2));\n\n    // ignore directional mouse movements that are too close\n    if (distance < rect.width * DIRECTION_RADIUS_BUFFER) {\n      return;\n    }\n\n    var angle, side;\n    if (offsetX > 0) {\n      angle = Math.atan((-1 * offsetY) / offsetX) * (180 / Math.PI);\n      side = \"Right\";\n    } else {\n      angle = Math.atan(offsetY / offsetX) * (180 / Math.PI);\n      side = \"Left\";\n    }\n\n    var direction;\n    if (angle > 67.5) {\n      direction = \"Up\";\n    } else if (angle > 22.5) {\n      direction = \"Up\" + side;\n    } else if (angle > -22.5) {\n      direction = side;\n    } else if (angle > -67.5) {\n      direction = \"Down\" + side;\n    } else {\n      direction = \"Down\";\n    }\n\n    this.invokeEvent(\"mouse\" + direction);\n  };\n\n  onAttention = () => {\n    this.invokeEvent(\"attention\");\n  };\n\n  invokeEvent(eventName) {\n    // console.log(\"event: \" + eventName);\n\n    var newState = this.stateMachine.getNewState(eventName);\n    if (newState.name === this.state.newState.name) {\n      return;\n    }\n\n    if (this.props.onSnippetChanged) {\n      this.props.onSnippetChanged(newState.name);\n    }\n\n    var oldState = eventName === \"failed\" ? newState : this.state.newState;\n\n    this.setState({\n      oldState: oldState,\n      newState: newState,\n    });\n  }\n\n  onVideoLoaded = () => {\n    if (!this.onLoadedCalled) {\n      this.onLoadedCalled = true;\n    }\n    if (this.props.onLoaded) {\n      this.props.onLoaded();\n    }\n  };\n\n  render() {\n    return (\n      <div\n        ref={this.rootRef}\n        onMouseEnter={this.onAttention}\n        onClick={this.onAttention}\n        style={{\n          position: \"relative\",\n          width: this.props.width,\n          height: this.props.height,\n        }}\n      >\n        <SnippetTransition\n          ref={this.snippetRef}\n          mediaPath={this.props.snippetsMediaPath}\n          width={this.props.width}\n          height={this.props.height}\n          name={this.state.oldState.name}\n          newName={this.state.newState.name}\n          onVideoLoaded={this.onVideoLoaded}\n        />\n      </div>\n    );\n  }\n}\n","import React from \"react\";\nimport ReactivePortrait from \"./components/ReactivePortrait\";\nimport \"./App.css\";\n\nexport default class App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      snippetName: ReactivePortrait.defaultSnippet,\n    };\n  }\n\n  onPortraitChanged = (snippetName) => {\n    this.setState({ snippetName: snippetName });\n  };\n\n  render() {\n    const params = new URL(document.location).searchParams;\n    const names = (params.get(\"names\") ?? params.get(\"name\") ?? \"shuw\").split(\n      \",\"\n    );\n\n    const portraits = names.map((name) => {\n      return (\n        <div style={{ display: \"inline-block\", padding: \"10px\" }}>\n          <ReactivePortrait\n            snippetsMediaPath={\"/reactive-portrait/media/\" + name}\n            onSnippetChanged={this.onPortraitChanged}\n            width={400}\n            height={400}\n          />\n        </div>\n      );\n    });\n\n    const hideStateInfo =\n      params.get(\"hideStateInfo\") !== null || portraits.length !== 1;\n\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <div>{portraits}</div>\n          {hideStateInfo ? null : (\n            <div style={{ paddingTop: \"20px\" }}>{this.state.snippetName}</div>\n          )}\n        </header>\n      </div>\n    );\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}
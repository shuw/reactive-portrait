{"version":3,"sources":["logic/States.js","logic/StateMachine.js","components/Snippet.js","components/SnippetTransition.js","components/ReactivePortrait.js","App.js","serviceWorker.js","index.js"],"names":["States","options","DIRECTION_PROB","IDLE_BEFORE_DIRECTION","lookAround","idle","events","tick50","minTimeElapsedInState","wave","probability","smile","lookingAround","lookingAround2","attention","thumbsUp","thinking","bye","lookLeft","lookingLeft","lookRight","lookingRight","lookDown","lookingDown","lookUp","lookingUp","mouseUp","mouseUpLeft","lookingUpLeft","mouseUpRight","lookingUpRight","mouseLeft","mouseRight","mouseDown","mouseDownLeft","lookingDownLeft","mouseDownRight","lookingDownRight","almostFinished","knockKnock","StateMachine","initialStateName","this","states","get","_setState","_state","event","_updateState","stateInfo","name","_stateStartTime","newStates","Date","getTime","randomFloat","Math","random","Object","entries","entry","newStateName","stateName","info","Snippet","props","onVideoLoaded","e","videoRef","current","currentTime","getVideoStartTime","onVideoError","hasError","React","createRef","readyState","isVideoReady","duration","style","position","top","left","width","height","borderRadius","WebkitMaskImage","ref","autoPlay","muted","loop","playsInline","onError","onLoadedData","opacity","src","mediaPath","Component","SnippetTransition","updateTransition","state","transitionFraction","snippetRef","transitionStartTime","newName","playFromBeginning","timeElapsed","min","setState","isAlmostFinished","hasFailedToLoad","nextProps","nextState","_timer","window","setInterval","clearInterval","key","ReactivePortrait","tick50Ms","invokeEvent","onMouseMove","rootRef","currTime","lastMouseEvent","angle","side","direction","rect","getBoundingClientRect","centerX","x","round","centerY","y","offsetX","clientX","offsetY","clientY","sqrt","pow","atan","PI","onAttention","onLoadedCalled","onLoaded","stateMachine","defaultSnippet","stateMachineOptions","oldState","getState","newState","addEventListener","eventName","getNewState","onSnippetChanged","onMouseEnter","onClick","snippetsMediaPath","App","onPortraitChanged","snippetName","params","URL","document","location","searchParams","names","split","portraits","map","display","padding","textAlign","hideStateInfo","length","className","right","color","href","target","paddingTop","fontSize","Boolean","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.4ba4eeba.chunk.js","sourcesContent":["export default class States {\n  static get(options) {\n    var DIRECTION_PROB, IDLE_BEFORE_DIRECTION;\n    if (options.lookAround) {\n      DIRECTION_PROB = 1;\n      IDLE_BEFORE_DIRECTION = 1;\n    } else {\n      DIRECTION_PROB = 0.02;\n      IDLE_BEFORE_DIRECTION = 5;\n    }\n\n    return {\n      idle: {\n        events: {\n          tick50: {\n            minTimeElapsedInState: 10,\n            wave: { probability: 0.001 },\n            smile: { probability: 0.0005 },\n            lookingAround: { probability: 0.0003 },\n            lookingAround2: { probability: 0.0002 },\n          },\n\n          attention: {\n            wave: { probability: 0.2 },\n            thumbsUp: { probability: 0.3 },\n            smile: { probability: 0.3 },\n            thinking: { probability: 0.2 },\n          },\n\n          thumbsUp: { thumbsUp: {} },\n\n          bye: { bye: {} },\n          lookLeft: { lookingLeft: {} },\n          lookRight: { lookingRight: {} },\n          lookDown: { lookingDown: {} },\n          lookUp: { lookingUp: {} },\n\n          mouseUp: {\n            minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n            lookingUp: { probability: DIRECTION_PROB },\n          },\n          mouseUpLeft: {\n            minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n            lookingUpLeft: { probability: DIRECTION_PROB },\n          },\n          mouseUpRight: {\n            minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n            lookingUpRight: { probability: DIRECTION_PROB },\n          },\n          mouseLeft: {\n            minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n            lookingLeft: { probability: DIRECTION_PROB },\n          },\n          mouseRight: {\n            minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n            lookingRight: { probability: DIRECTION_PROB },\n          },\n          mouseDown: {\n            minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n            lookingDown: { probability: DIRECTION_PROB * 0.5 },\n          },\n          mouseDownLeft: {\n            minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n            lookingDownLeft: { probability: DIRECTION_PROB },\n          },\n          mouseDownRight: {\n            minTimeElapsedInState: IDLE_BEFORE_DIRECTION,\n            lookingDownRight: { probability: DIRECTION_PROB },\n          },\n        },\n      },\n\n      bye: {\n        events: { almostFinished: { wave: {} } },\n      },\n\n      smile: { events: { almostFinished: { idle: {} } } },\n      wave: { events: { almostFinished: { idle: {} } } },\n      thumbsUp: { events: { almostFinished: { idle: {} } } },\n      knockKnock: { events: { almostFinished: { idle: {} } } },\n      thinking: { events: { almostFinished: { idle: {} } } },\n      lookingAround: { events: { almostFinished: { idle: {} } } },\n      lookingAround2: { events: { almostFinished: { idle: {} } } },\n      lookingUp: { events: { almostFinished: { idle: {} } } },\n      lookingUpLeft: { events: { almostFinished: { idle: {} } } },\n      lookingUpRight: { events: { almostFinished: { idle: {} } } },\n      lookingLeft: { events: { almostFinished: { idle: {} } } },\n      lookingRight: { events: { almostFinished: { idle: {} } } },\n      lookingDown: { events: { almostFinished: { idle: {} } } },\n      lookingDownLeft: { events: { almostFinished: { idle: {} } } },\n      lookingDownRight: { events: { almostFinished: { idle: {} } } },\n    };\n  }\n}\n","import States from \"./States\";\n\nexport default class StateMachine {\n  constructor(initialStateName, options = {}) {\n    this.states = States.get(options);\n    this._setState(initialStateName);\n  }\n\n  getState() {\n    return this._state;\n  }\n\n  getNewState(event) {\n    this._updateState(event);\n    return this._state;\n  }\n\n  _updateState(event) {\n    var stateInfo = this.states[this._state.name];\n\n    // handle failure by going back to idle\n    if (event === \"failed\") {\n      this._setState(\"idle\");\n\n      // disable minTimeElapsedInState\n      this._stateStartTime = 0;\n      return;\n    }\n\n    var newStates = stateInfo.events[event];\n    if (!newStates) {\n      return;\n    }\n\n    if (newStates.minTimeElapsedInState) {\n      var timeInStateMs = new Date().getTime() - this._stateStartTime;\n      if (timeInStateMs < newStates.minTimeElapsedInState * 1000) {\n        return;\n      }\n    }\n\n    const randomFloat = Math.random();\n    var probability = 0.0;\n    for (const entry of Object.entries(newStates)) {\n      const newStateName = entry[0];\n      if (!(newStateName in this.states)) {\n        continue;\n      }\n\n      probability += entry[1].probability || 1.0;\n      if (probability < randomFloat) {\n        continue;\n      }\n\n      // found new state, reset timer\n      this._setState(newStateName);\n      return;\n    }\n  }\n\n  _setState(stateName) {\n    this._state = {\n      name: stateName,\n      info: this.states[stateName],\n    };\n    this._stateStartTime = new Date().getTime();\n  }\n}\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\n// How close to the end of a video before returning it's almost finished\nconst VIDEO_ALMOST_FINISHED_THRESHOLD_S = 0.1;\n\n// Encapsulates a Video Snippet\nexport default class Snippet extends React.Component {\n  static propTypes = {\n    width: PropTypes.number,\n    height: PropTypes.number,\n    name: PropTypes.string,\n    opacity: PropTypes.number,\n    onVideoLoaded: PropTypes.func,\n    mediaPath: PropTypes.string,\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.hasError = false;\n    this.videoRef = React.createRef();\n  }\n\n  isVideoReady() {\n    return this.videoRef.current && this.videoRef.current.readyState === 4;\n  }\n\n  playFromBeginning() {\n    if (!this.isVideoReady()) {\n      return;\n    }\n\n    this.videoRef.current.currentTime = this.getVideoStartTime();\n  }\n\n  isAlmostFinished() {\n    if (!this.isVideoReady()) {\n      return false;\n    }\n\n    return (\n      this.videoRef.current.duration - this.videoRef.current.currentTime <\n      VIDEO_ALMOST_FINISHED_THRESHOLD_S\n    );\n  }\n\n  onVideoLoaded = (e) => {\n    this.videoRef.current.currentTime = this.getVideoStartTime();\n    if (this.props.onVideoLoaded) {\n      this.props.onVideoLoaded(e);\n    }\n  };\n\n  onVideoError = (e) => {\n    this.hasError = true;\n  };\n\n  hasFailedToLoad() {\n    return this.hasError;\n  }\n\n  getVideoStartTime() {\n    if (this.props.name === \"idle\" && this.videoRef.current?.duration) {\n      return Math.random() * this.videoRef.current.duration;\n    }\n    return 0;\n  }\n\n  render() {\n    return (\n      <div\n        style={{\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          width: this.props.width,\n          height: this.props.height,\n          borderRadius: this.props.width / 2,\n          WebkitMaskImage:\n            \"-webkit-radial-gradient(circle, white 100%, black 100%)\",\n        }}\n      >\n        <video\n          ref={this.videoRef}\n          autoPlay\n          muted\n          loop\n          playsInline\n          onError={this.onVideoError}\n          onLoadedData={this.onVideoLoaded}\n          width={this.props.width}\n          height={this.props.height}\n          style={{\n            opacity: this.props.opacity,\n          }}\n        >\n          <source src={this.props.mediaPath + \"/\" + this.props.name + \".mov\"} />\n        </video>\n      </div>\n    );\n  }\n}\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport Snippet from \"./Snippet\";\n\nconst VIDEO_CROSS_FADE_TIME_MS = 400;\nconst FRAME_INTERVAL_MS = 30;\n\n// Manages cross-fade between two Snippet Videos\nexport default class SnippetTransition extends React.Component {\n  static propTypes = {\n    width: PropTypes.number,\n    height: PropTypes.number,\n    name: PropTypes.string,\n    newName: PropTypes.string,\n    mediaPath: PropTypes.string,\n    onError: PropTypes.func,\n    onVideoLoaded: PropTypes.func,\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.transitionStartTime = null;\n    this.state = {\n      transitionFraction: 1.0,\n    };\n\n    this.snippetRef = React.createRef();\n  }\n\n  isAlmostFinished() {\n    return this.snippetRef.current?.isAlmostFinished() ?? false;\n  }\n\n  hasFailedToLoad() {\n    return this.snippetRef.current?.hasFailedToLoad() ?? false;\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if (nextProps.newName === this.props.newName) {\n      return true;\n    }\n\n    nextState.transitionFraction = 0.0;\n    this.transitionStartTime = null;\n\n    return true;\n  }\n\n  componentDidMount() {\n    this._timer = window.setInterval(this.updateTransition, FRAME_INTERVAL_MS);\n  }\n\n  componentWillUnmount() {\n    window.clearInterval(this._timer);\n  }\n\n  updateTransition = () => {\n    if (this.state.transitionFraction >= 1.0) {\n      return;\n    }\n\n    if (!this.snippetRef.current) {\n      return;\n    }\n\n    if (!this.snippetRef.current.isVideoReady()) {\n      // wait for video to be ready before transitioning\n      return;\n    }\n\n    // reset transition\n    if (!this.transitionStartTime) {\n      this.transitionStartTime = new Date().getTime();\n\n      // play from beginning (if not resetting to idle state)\n      if (this.props.name !== \"idle\" || this.props.newName !== \"idle\") {\n        this.snippetRef.current.playFromBeginning();\n      }\n    }\n\n    var timeElapsed = new Date().getTime() - this.transitionStartTime;\n    var transitionFraction = Math.min(\n      timeElapsed / VIDEO_CROSS_FADE_TIME_MS,\n      1.0\n    );\n\n    this.setState({\n      transitionFraction: transitionFraction,\n    });\n  };\n\n  onVideoLoaded = () => {\n    this.props.onVideoLoaded();\n  };\n\n  render() {\n    if (this.props.newName && this.props.newName !== this.props.name) {\n      return (\n        <div>\n          <Snippet\n            key={this.props.name}\n            mediaPath={this.props.mediaPath}\n            width={this.props.width}\n            height={this.props.height}\n            name={this.props.name}\n            opacity={1.0}\n          />\n          <Snippet\n            ref={this.snippetRef}\n            key={this.props.newName}\n            mediaPath={this.props.mediaPath}\n            opacity={this.state.transitionFraction}\n            width={this.props.width}\n            height={this.props.height}\n            name={this.props.newName}\n            onVideoLoaded={this.onVideoLoaded}\n          />\n        </div>\n      );\n    } else {\n      return (\n        <div>\n          <Snippet\n            ref={this.snippetRef}\n            key={this.props.name}\n            mediaPath={this.props.mediaPath}\n            width={this.props.width}\n            height={this.props.height}\n            name={this.props.name}\n            onVideoLoaded={this.onVideoLoaded}\n            opacity={1.0}\n          />\n        </div>\n      );\n    }\n  }\n}\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport StateMachine from \"../logic/StateMachine\";\nimport SnippetTransition from \"./SnippetTransition\";\n\nconst DIRECTION_RADIUS_BUFFER = 0.75;\nconst MIN_DURATION_BETWEEN_MOUSE_EVENT_MS = 50;\n\n// TODO\n// * Incorporate yawn state\n// * Incorporate gyro signal\n// * Support for delayed state change. Short term memory.\nexport default class ReactivePortrait extends React.Component {\n  static defaultSnippet = \"idle\";\n\n  static propTypes = {\n    width: PropTypes.number,\n    height: PropTypes.number,\n    onSnippetChanged: PropTypes.func,\n    snippetsMediaPath: PropTypes.string,\n    onLoaded: PropTypes.func,\n    stateMachineOptions: PropTypes.object,\n  };\n\n  constructor(props) {\n    super(props);\n    this.stateMachine = new StateMachine(\n      ReactivePortrait.defaultSnippet,\n      props.stateMachineOptions ?? {}\n    );\n    this.rootRef = React.createRef();\n    this.lastMouseEvent = new Date().getTime();\n    this.snippetRef = React.createRef();\n    this.onLoadedCalled = false;\n\n    this.state = {\n      stateMachine: this.stateMachine,\n      oldState: this.stateMachine.getState(),\n      newState: this.stateMachine.getState(),\n    };\n  }\n\n  componentDidMount() {\n    this._timer = window.setInterval(this.tick50Ms, 100);\n    window.addEventListener(\"mousemove\", this.onMouseMove);\n  }\n\n  componentWillUnmount() {\n    window.clearInterval(this._timer);\n  }\n\n  tick50Ms = () => {\n    this.invokeEvent(\"tick50Ms\");\n\n    if (this.snippetRef.current?.hasFailedToLoad()) {\n      this.invokeEvent(\"failed\");\n    }\n\n    if (this.snippetRef.current?.isAlmostFinished()) {\n      this.invokeEvent(\"almostFinished\");\n    }\n  };\n\n  onMouseMove = (event) => {\n    if (!this.rootRef.current) {\n      return;\n    }\n\n    const currTime = new Date().getTime();\n    const elapsedMs = currTime - this.lastMouseEvent;\n    if (elapsedMs < MIN_DURATION_BETWEEN_MOUSE_EVENT_MS) {\n      return;\n    }\n    this.lastMouseEvent = currTime;\n\n    const rect = this.rootRef.current.getBoundingClientRect();\n    const centerX = rect.x + Math.round(rect.width / 2);\n    const centerY = rect.y + Math.round(rect.height / 2);\n\n    const offsetX = event.clientX - centerX;\n    const offsetY = event.clientY - centerY;\n\n    const distance = Math.sqrt(Math.pow(offsetX, 2) + Math.pow(offsetY, 2));\n\n    // ignore directional mouse movements that are too close\n    if (distance < rect.width * DIRECTION_RADIUS_BUFFER) {\n      return;\n    }\n\n    var angle, side;\n    if (offsetX > 0) {\n      angle = Math.atan((-1 * offsetY) / offsetX) * (180 / Math.PI);\n      side = \"Right\";\n    } else {\n      angle = Math.atan(offsetY / offsetX) * (180 / Math.PI);\n      side = \"Left\";\n    }\n\n    var direction;\n    if (angle > 67.5) {\n      direction = \"Up\";\n    } else if (angle > 22.5) {\n      direction = \"Up\" + side;\n    } else if (angle > -22.5) {\n      direction = side;\n    } else if (angle > -67.5) {\n      direction = \"Down\" + side;\n    } else {\n      direction = \"Down\";\n    }\n\n    this.invokeEvent(\"mouse\" + direction);\n  };\n\n  onAttention = () => {\n    this.invokeEvent(\"attention\");\n  };\n\n  invokeEvent(eventName) {\n    // console.log(\"event: \" + eventName);\n\n    var newState = this.stateMachine.getNewState(eventName);\n    if (newState.name === this.state.newState.name) {\n      return;\n    }\n\n    if (this.props.onSnippetChanged) {\n      this.props.onSnippetChanged(newState.name);\n    }\n\n    var oldState = eventName === \"failed\" ? newState : this.state.newState;\n\n    this.setState({\n      oldState: oldState,\n      newState: newState,\n    });\n  }\n\n  onVideoLoaded = () => {\n    if (!this.onLoadedCalled) {\n      this.onLoadedCalled = true;\n    }\n    if (this.props.onLoaded) {\n      this.props.onLoaded();\n    }\n  };\n\n  render() {\n    return (\n      <div\n        ref={this.rootRef}\n        onMouseEnter={this.onAttention}\n        onClick={this.onAttention}\n        style={{\n          position: \"relative\",\n          width: this.props.width,\n          height: this.props.height,\n        }}\n      >\n        <SnippetTransition\n          ref={this.snippetRef}\n          mediaPath={this.props.snippetsMediaPath}\n          width={this.props.width}\n          height={this.props.height}\n          name={this.state.oldState.name}\n          newName={this.state.newState.name}\n          onVideoLoaded={this.onVideoLoaded}\n        />\n      </div>\n    );\n  }\n}\n","import React from \"react\";\nimport ReactivePortrait from \"./components/ReactivePortrait\";\nimport \"./App.css\";\n\nexport default class App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      snippetName: ReactivePortrait.defaultSnippet,\n    };\n  }\n\n  onPortraitChanged = (snippetName) => {\n    this.setState({ snippetName: snippetName });\n  };\n\n  render() {\n    const params = new URL(document.location).searchParams;\n    const names = (params.get(\"names\") ?? params.get(\"name\") ?? \"shuw\").split(\n      \",\"\n    );\n\n    const stateMachineOptions = {\n      lookAround: params.get(\"lookAround\") !== null,\n    };\n\n    const portraits = names.map((name) => {\n      return (\n        <div\n          key={name}\n          style={{\n            display: \"inline-block\",\n            width: \"400px\",\n            padding: \"20px\",\n            textAlign: \"center\",\n          }}\n        >\n          <ReactivePortrait\n            stateMachineOptions={stateMachineOptions}\n            snippetsMediaPath={\"/reactive-portrait/media/\" + name}\n            onSnippetChanged={this.onPortraitChanged}\n            width={400}\n            height={400}\n          />\n        </div>\n      );\n    });\n\n    const hideStateInfo =\n      params.get(\"hideStateInfo\") !== null || portraits.length !== 1;\n\n    return (\n      <div className=\"App\">\n        <a\n          style={{\n            position: \"absolute\",\n            top: \"20px\",\n            right: \"20px\",\n            color: \"#aaa\",\n          }}\n          href=\"https://github.com/shuw/reactive-portrait\"\n          target=\"_blnk\"\n        >\n          Source Code\n        </a>\n        <div style={{ paddingTop: \"200px\" }}>{portraits}</div>\n        {hideStateInfo ? null : (\n          <div style={{ color: \"#aaa\", paddingTop: \"10px\", fontSize: \"20px\" }}>\n            {this.state.snippetName}\n          </div>\n        )}\n      </div>\n    );\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}